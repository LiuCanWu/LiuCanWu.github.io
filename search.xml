<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构-stack</title>
    <url>/2019/08/08/stack/</url>
    <content><![CDATA[<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>数学表达式中有中缀表达式与后缀表达式，如 a + b * c - d / e 和 abc *+ de /-</p>
<p>需要某种存储方法，能顺序存储运算数，并在需要时“倒序输出”</p>
<p>堆栈(Stack): 具有一定操作约束的<strong>线性表</strong>，且只在一端(栈顶 ，TOP)做插入(入栈，Push)，删除(出栈，Pop),<strong>后入先出(LIFO)的存储顺序</strong>，Push 与 Pop 可以穿插交替进行</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol>
<li><p>栈的顺序存储结构：通常由一个一维数组和一个记录栈顶元素位置的变量组成</p>
<p><code>void Push(Stack PtrS, Elementtype item){</code></p>
<p><code>if (Ptrs-&gt;Top == MaxSize-1){</code></p>
<p><code>printf(&quot;堆栈满&quot;);return;</code></p>
<p><code>}else {</code></p>
<p><code>Ptrs-&gt;Data[++(Ptrs-&gt;Top)] - item</code>;</p>
<p><code>return;</code></p>
<p><code>}</code> </p>
<p><code>}</code></p>
<p><code>ElementType Pop(Stack PtrS){</code></p>
<p><code>if(PtrS-&gt;Top == -1){</code></p>
<p><code>printf(&quot;堆栈空&quot;)；</code></p>
<p><code>return ERROR;</code></p>
<p><code>}else</code></p>
<p><code>return (PtrS-&gt;Data[(PtrS-&gt;Top)--]);</code></p>
<p><code>}</code></p>
</li>
<li><p>堆栈的链式存储：实际上是一个单链表，叫做链栈，插入如删除操作只能在链栈的栈顶进行。</p>
<p><code>Stack CreatStack(){
  Stack S;
  S = (Stack)malloc(sizeof(struct SNode));
  S-&gt;Next = NULL;
  return S;
}
int ISEmpty(Stack S)
{
  return (S-&gt;Next == NULL);
}</code></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>artical</title>
    <url>/2019/08/03/artical/</url>
    <content><![CDATA[<h4 id="摘录自"><a href="#摘录自" class="headerlink" title="摘录自"></a>摘录自</h4><p><a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">http://c.biancheng.net/cplus/</a></p>
<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><blockquote>
<p><strong>类只是一张图纸，起到说明的作用，不占用内存空间；对象才是具体的零件，要有地方来存放，才会占用内存空间。</strong></p>
<p><strong>类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了</strong></p>
<p><strong>创建的对象 stu 在栈上分配内存，需要使用<code>&amp;</code>获取它的地址,</strong></p>
<p><strong>当然，也可以在堆上创建对象，这个时候就需要使用前面讲到的<code>new</code>关键字.也就是说，使用 new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。</strong></p>
<p>有了对象指针后，可以通过箭头<code>-&gt;</code>来访问对象的成员变量和成员函数,通过对象名字访问成员使用点号<code>.</code>，通过对象指针访问成员使用箭头<code>-&gt;</code>，这和结构体非常类似。</p>
</blockquote>
<blockquote>
<p>  在 C++ 中，通过类名就可以创建对象，即将图纸生产成零件，这个过程叫做类的实例化，因此也称对象是类的一个实例（Ins<a href="http://c.biancheng.net/ref/tan.html" target="_blank" rel="noopener">tan</a>ce）。</p>
<p>有些资料也将类的成员变量称为属性（Property），将类的成员函数称为方法（Method）。  </p>
</blockquote>
<blockquote>
<p>C++ 中的输入与输出可以看做是一连串的数据流，输入即可视为从文件或键盘中输入程序中的一串数据流，而输出则可以视为从程序中输出一连串的数据流到显示屏或文件中。</p>
</blockquote>
<blockquote>
<p>cout 和 cin 都是 C++ 的内置对象，而不是关键字。C++ 库定义了大量的类（Class），程序员可以使用它们来创建对象，cout 和 cin 就分别是 ostream 和 istream 类的对象，只不过它们是由标准库的开发者提前创建好的，可以直接拿来使用。这种在 C++ 中提前创建好的对象称为内置对象。</p>
</blockquote>
<blockquote>
<p>C语言并没有彻底从语法上支持“真”和“假”，只是用 0 和非 0 来代表。这点在 <a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a> 中得到了改善，C++ 新增了 <strong>bool 类型（布尔类型）</strong>，它一般占用 1 个字节长度。bool 类型只有两个取值，true 和 false：true 表示“真”，false 表示“假</p>
</blockquote>
<blockquote>
<p>  但在<a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a>中，这完全没有必要。C++ 允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载（Function Overloading）。借助重载，一个函数名可以有多种用途。参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。 </p>
<p>从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样 </p>
</blockquote>
<blockquote>
<p><code>::</code>被称为域解析符（也称作用域运算符或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。</p>
</blockquote>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><blockquote>
<p>在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。<strong>并且类的声明和成员函数的定义都是类定义的一部分</strong></p>
</blockquote>
<blockquote>
<p>在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。  </p>
</blockquote>
<blockquote>
<p>除了 set 函数和 get 函数，在创建对象时还可以调用构造函数来初始化各个成员变量，我们将在《<a href="http://c.biancheng.net/view/2221.html" target="_blank" rel="noopener">C++构造函数</a>》一节中展开讨论。不过构造函数只能给成员变量赋值一次，以后再修改还得借助 set 函数</p>
</blockquote>
<blockquote>
<p>在栈上创建对象时，实参位于对象名后面，例如<code>Student stu(&quot;小明&quot;, 15, 92.5f)</code>；在堆上创建对象时，实参位于类名后面，例如<code>new Student(&quot;李华&quot;, 16, 96)</code>。</p>
<p>构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，这意味着：不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许；函数体中不能有 return 语句。</p>
</blockquote>
<h2 id="四-：继承与派生"><a href="#四-：继承与派生" class="headerlink" title="四 ：继承与派生"></a>四 ：继承与派生</h2><ol>
<li><p>派生类除了拥有基类的成员，还可以定义自己的新成员，以增强类的功能。</p>
</li>
<li><p>如果希望基类的成员既<strong>不向外暴露（不能通过对象访问</strong>），还能在派生类中使用，那么只能声明为 protected。</p>
</li>
<li><table>
<thead>
<tr>
<th>继承方式/基类成员</th>
<th>public成员</th>
<th>protected成员</th>
<th>private成员</th>
</tr>
</thead>
<tbody><tr>
<td>public继承</td>
<td>public</td>
<td>protected</td>
<td>不可见</td>
</tr>
<tr>
<td>protected继承</td>
<td>protected</td>
<td>protected</td>
<td>不可见</td>
</tr>
<tr>
<td>private继承</td>
<td>private</td>
<td>private</td>
<td>不可见</td>
</tr>
</tbody></table>
</li>
<li><p>因为 m_hobby 是 private 属性的，在派生类中不可见，所以只能借助基类的 public 成员函数 sethobby()、gethobby() 来访问。在派生类中访问基类 private 成员的唯一方法就是借助基类的非 private 成员函数，如果基类没有非 private 成员函数，那么该成员在派生类中将无法访问。</p>
</li>
<li><p>如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会遮蔽从基类继承过来的成员，即:<strong>基类成员函数和派生类成员函数不会构成重载</strong>，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样.</p>
</li>
<li><p>类的构造函数不能被继承。构造函数不能被继承是有道理的，因为即使继承了，它的名字和派生类的名字也不一样，不能成为派生类的构造函数，当然更不能成为普通的成员函数。</p>
</li>
<li><p>在派生类的构造函数中调用基类的构造函数，来对基类的private 或 protected 成员进行初始化。<strong>因为基类构造函数不会被继承</strong>，不能当做普通的成员函数来调用。换句话说，只能将基类构造函数的调用放在函数头部，不能放在函数体中</p>
</li>
<li><p><strong>虚继承（Virtual Inheritance）</strong></p>
<p>为了解决多继承时的命名冲突和冗余数据问题，<a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a> 提出了虚继承，使得在派生类中只保留一份间接基类的成员。虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p>
</li>
<li><p><strong>向上转型（Upcasting)</strong></p>
<p>类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，向上转型是只能将派生类赋值给基类</p>
<p>将派生类对象赋值给基类对象时，会舍弃派生类新增的成员，也就是“大材小用”</p>
<ol start="10">
<li><p><strong>将派生类指针赋值给基类指针</strong></p>
<p>编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。</p>
</li>
<li><p><strong>因为引用和指针并没有本质上的区别，引用仅仅是对指针进行了简单封装</strong></p>
</li>
</ol>
<h2 id="五：多态与虚函数"><a href="#五：多态与虚函数" class="headerlink" title="五：多态与虚函数"></a>五：多态与虚函数</h2><ol>
<li><p>换句话说，<strong>通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数</strong>。为了消除这种尴尬，让基类指针能够访问派生类的成员函数，<a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a> 增加了<strong>虚函数（Virtual Function）</strong>。使用虚函数非常简单，只需要在函数声明前面增加 virtual 关键字。  </p>
<p>有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为<strong>多态（Polymorphism）</strong></p>
<p><strong>多态是指通过基类的指针既可以访问基类的成员，也可以访问派生类的成员</strong>。</p>
<p>多态是面向对象编程的主要特征之一，C++中虚函数的唯一用处就是构成多态,在于具有复杂继承关系的大中型程序，多态可以增加其灵活性，让代码更具有表现力</p>
</li>
<li><p><strong>纯虚函数</strong></p>
<p>Line 类表示“线”，没有面积和体积，但它仍然定义了 area() 和 volume() 两个纯虚函数。这样的用意很明显：Line 类不需要被实例化，但是它为派生类提供了“约束条件”，派生类必须要实现这两个函数，完成计算面积和体积的功能，否则就不能实例化</p>
<h2 id="六：运算符重载"><a href="#六：运算符重载" class="headerlink" title="六：运算符重载"></a>六：运算符重载</h2><ol>
<li><p><strong>运算符重载实质</strong></p>
<p>运算符重载其实就是定义一个函数，在函数体内实现想要的功能，当用到该运算符时，编译器会自动调用这个函数。也就是说，运算符重载是通过函数实现的，它本质上是函数重载。</p>
</li>
<li><p><strong>友元函数</strong></p>
<p>运算符重载函数不是 complex 类的成员函数，但是却用到了 complex 类的 private 成员变量，所以必须在 complex 类中将该函数声明为友元函数。<strong>即将运算符重载函数作为全局函数时</strong>，二元操作符就需要两个参数，一元操作符需要一个参数，<strong>而且其中必须有一个参数是对象，</strong>好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质</p>
</li>
<li><p><strong>运算符重载的意义</strong></p>
<p>虽然运算符重载所实现的功能完全可以用函数替代，但运算符重载使得程序的书写更加人性化，易于阅读。运算符被重载后，原有的功能仍然保留，没有丧失或改变。通过运算符重载，扩大了C++已有运算符的功能，使之能用于对象。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
